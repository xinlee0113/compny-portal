# CANæ€»çº¿åº”ç”¨é›†æˆæœ€ä½³å®è·µæ¡ˆä¾‹

> **ä½œè€…**: æ™ºäº‘ç§‘æŠ€è½¦è½½æŠ€æœ¯å›¢é˜Ÿ  
> **å‘å¸ƒæ—¶é—´**: 2024å¹´7æœˆ  
> **æ ‡ç­¾**: `CANæ€»çº¿` `è½¦è½½é€šä¿¡` `æ±½è½¦ç”µå­` `ç³»ç»Ÿé›†æˆ` `å®æˆ˜æ¡ˆä¾‹`

---

## ğŸš— å¼•è¨€

CAN(Controller Area Network)æ€»çº¿æ˜¯ç°ä»£æ±½è½¦ç”µå­ç³»ç»Ÿçš„ç¥ç»ç½‘ç»œï¼Œè¿æ¥ç€å‘åŠ¨æœºæ§åˆ¶å•å…ƒã€åˆ¶åŠ¨ç³»ç»Ÿã€ä»ªè¡¨ç›˜ç­‰å„ä¸ªå…³é”®ç»„ä»¶ã€‚å¯¹äºè½¦è½½åº”ç”¨å¼€å‘è€…æ¥è¯´ï¼ŒæŒæ¡CANæ€»çº¿é›†æˆæŠ€æœ¯æ˜¯å®ç°æ·±åº¦è½¦è¾†åŠŸèƒ½çš„å…³é”®ã€‚

æœ¬æ–‡å°†é€šè¿‡çœŸå®æ¡ˆä¾‹ï¼Œæ·±å…¥è®²è§£CANæ€»çº¿åœ¨è½¦è½½åº”ç”¨ä¸­çš„é›†æˆæ–¹æ³•ã€æœ€ä½³å®è·µå’Œå¸¸è§é—®é¢˜è§£å†³æ–¹æ¡ˆã€‚

---

## ğŸ“‹ ç›®å½•

1. [CANæ€»çº¿åŸºç¡€](#1-canæ€»çº¿åŸºç¡€)
2. [è½¦è½½åº”ç”¨é›†æˆæ¶æ„](#2-è½¦è½½åº”ç”¨é›†æˆæ¶æ„)
3. [å®æˆ˜æ¡ˆä¾‹ï¼šæ™ºèƒ½ä»ªè¡¨æ•°æ®è¯»å–](#3-å®æˆ˜æ¡ˆä¾‹æ™ºèƒ½ä»ªè¡¨æ•°æ®è¯»å–)
4. [å®æˆ˜æ¡ˆä¾‹ï¼šè½¦è¾†æ§åˆ¶æŒ‡ä»¤å‘é€](#4-å®æˆ˜æ¡ˆä¾‹è½¦è¾†æ§åˆ¶æŒ‡ä»¤å‘é€)
5. [æ•…éšœè¯Šæ–­ä¸OBDé›†æˆ](#5-æ•…éšœè¯Šæ–­ä¸obdé›†æˆ)
6. [å®‰å…¨ä¸æƒé™ç®¡ç†](#6-å®‰å…¨ä¸æƒé™ç®¡ç†)
7. [æ€§èƒ½ä¼˜åŒ–ä¸ç›‘æ§](#7-æ€§èƒ½ä¼˜åŒ–ä¸ç›‘æ§)
8. [å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ](#8-å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ)

---

## 1. CANæ€»çº¿åŸºç¡€

### 1.1 CANæ€»çº¿åè®®æ¦‚è¿°

CANæ€»çº¿æ˜¯ä¸€ç§å¤šä¸»æœºä¸²è¡Œé€šä¿¡åè®®ï¼Œå…·æœ‰ä»¥ä¸‹ç‰¹ç‚¹ï¼š

- **é«˜å¯é æ€§**: å·®åˆ†ä¿¡å·ä¼ è¾“ï¼Œå¼ºæŠ—å¹²æ‰°èƒ½åŠ›
- **å®æ—¶æ€§**: ä¼˜å…ˆçº§ä»²è£æœºåˆ¶ï¼Œç¡®ä¿é‡è¦æ¶ˆæ¯ä¼˜å…ˆä¼ è¾“
- **å®¹é”™æ€§**: è‡ªåŠ¨é”™è¯¯æ£€æµ‹å’Œå¤„ç†æœºåˆ¶
- **çµæ´»æ€§**: æ”¯æŒå¤šèŠ‚ç‚¹åŠ¨æ€åŠ å…¥å’Œé€€å‡º

### 1.2 CANæ¶ˆæ¯æ ¼å¼

æ ‡å‡†CANå¸§ç»“æ„ï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ SOF(1)  â”‚ ID(11) â”‚ RTR(1)  â”‚ IDE(1)   â”‚ DATA(0-64)  â”‚ CRC(16) â”‚ EOF(7)  â”‚
â”‚ èµ·å§‹ä½  â”‚ æ ‡è¯†ç¬¦ â”‚ è¿œç¨‹å¸§  â”‚ æ‰©å±•å¸§   â”‚ æ•°æ®å­—æ®µ    â”‚ æ ¡éªŒç   â”‚ ç»“æŸä½  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.3 æ±½è½¦CANç½‘ç»œæ‹“æ‰‘

ç°ä»£æ±½è½¦é€šå¸¸åŒ…å«å¤šä¸ªCANç½‘ç»œï¼š

```
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚   è½¦è½½å¨±ä¹    â”‚
                    â”‚   ä¿¡æ¯ç³»ç»Ÿ    â”‚
                    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€CAN Gatewayâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                      â”‚                              â”‚
â”Œâ”€â”€â”€â–¼â”€â”€â”€â”€â”            â”Œâ”€â”€â”€â–¼â”€â”€â”€â”€â”                   â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”
â”‚åŠ¨åŠ›CAN â”‚            â”‚è½¦èº«CAN â”‚                   â”‚è¯Šæ–­CAN â”‚
â”‚500kbps â”‚            â”‚125kbps â”‚                   â”‚500kbps â”‚
â””â”€â”€â”€â”¬â”€â”€â”€â”€â”˜            â””â”€â”€â”€â”¬â”€â”€â”€â”€â”˜                   â””â”€â”€â”€â”€â”¬â”€â”€â”€â”˜
    â”‚                     â”‚                             â”‚
â”Œâ”€â”€â”€â–¼â”€â”€â”€â”€â”            â”Œâ”€â”€â”€â–¼â”€â”€â”€â”€â”                   â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”
â”‚å‘åŠ¨æœº  â”‚            â”‚è½¦ç¯æ§åˆ¶â”‚                   â”‚OBDæ¥å£ â”‚
â”‚ECU     â”‚            â”‚BCM     â”‚                   â”‚       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 2. è½¦è½½åº”ç”¨é›†æˆæ¶æ„

### 2.1 ç³»ç»Ÿæ¶æ„è®¾è®¡

è½¦è½½åº”ç”¨ä¸CANæ€»çº¿çš„é›†æˆæ¶æ„ï¼š

```kotlin
// CANé›†æˆæ¶æ„ç¤ºä¾‹
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                è½¦è½½åº”ç”¨å±‚                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚ ä»ªè¡¨åº”ç”¨    â”‚  â”‚ å¯¼èˆªåº”ç”¨    â”‚  â”‚ éŸ³ä¹åº”ç”¨    â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚             â”‚             â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                CANæœåŠ¡æŠ½è±¡å±‚                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚è½¦è¾†æ•°æ®æœåŠ¡ â”‚  â”‚æ§åˆ¶æŒ‡ä»¤æœåŠ¡ â”‚  â”‚è¯Šæ–­æœåŠ¡     â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚             â”‚             â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                CANé©±åŠ¨å±‚                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚SocketCAN    â”‚  â”‚ J1939åè®®   â”‚  â”‚ UDSåè®®     â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚             â”‚             â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  ç¡¬ä»¶CANæ§åˆ¶å™¨                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 æƒé™ä¸å®‰å…¨æ¨¡å‹

```kotlin
// æƒé™ç®¡ç†ç¤ºä¾‹
object CANPermissionManager {
    enum class CANPermission(val level: Int) {
        READ_ONLY(1),          // ä»…è¯»å–
        BASIC_CONTROL(2),      // åŸºç¡€æ§åˆ¶
        ADVANCED_CONTROL(3),   // é«˜çº§æ§åˆ¶
        DIAGNOSTIC(4)          // è¯Šæ–­æƒé™
    }
    
    fun checkPermission(appId: String, permission: CANPermission): Boolean {
        // éªŒè¯åº”ç”¨æƒé™é€»è¾‘
        return getAppPermissionLevel(appId) >= permission.level
    }
}
```

---

## 3. å®æˆ˜æ¡ˆä¾‹ï¼šæ™ºèƒ½ä»ªè¡¨æ•°æ®è¯»å–

### 3.1 éœ€æ±‚åˆ†æ

å¼€å‘ä¸€ä¸ªæ™ºèƒ½ä»ªè¡¨åº”ç”¨ï¼Œå®æ—¶æ˜¾ç¤ºï¼š
- è½¦é€Ÿã€è½¬é€Ÿã€æ²¹è€—
- å‘åŠ¨æœºæ¸©åº¦ã€æ²¹å‹
- æ•…éšœç¯çŠ¶æ€

### 3.2 CANæ¶ˆæ¯è§£æ

```kotlin
/**
 * è½¦è¾†æ•°æ®CANæ¶ˆæ¯è§£æå™¨
 */
class VehicleDataParser {
    
    companion object {
        // CAN IDå®šä¹‰ï¼ˆç¤ºä¾‹ï¼‰
        const val ENGINE_DATA_ID = 0x0CF00400    // å‘åŠ¨æœºæ•°æ®
        const val VEHICLE_SPEED_ID = 0x0CF00300  // è½¦é€Ÿæ•°æ®
        const val FUEL_CONSUMPTION_ID = 0x0CF00500 // æ²¹è€—æ•°æ®
    }
    
    /**
     * è§£æå‘åŠ¨æœºæ•°æ®
     */
    fun parseEngineData(canFrame: CANFrame): EngineData? {
        if (canFrame.id != ENGINE_DATA_ID) return null
        
        val data = canFrame.data
        if (data.size < 8) return null
        
        // æŒ‰ç…§J1939åè®®è§£æ
        val rpm = ((data[3].toInt() and 0xFF) shl 8) or (data[2].toInt() and 0xFF)
        val coolantTemp = data[0].toInt() and 0xFF - 40  // æ¸©åº¦åç§»40åº¦
        val oilPressure = data[4].toInt() and 0xFF * 4   // å‹åŠ›å•ä½è½¬æ¢
        
        return EngineData(
            rpm = rpm,
            coolantTemperature = coolantTemp,
            oilPressure = oilPressure,
            timestamp = System.currentTimeMillis()
        )
    }
    
    /**
     * è§£æè½¦é€Ÿæ•°æ®
     */
    fun parseVehicleSpeed(canFrame: CANFrame): VehicleSpeedData? {
        if (canFrame.id != VEHICLE_SPEED_ID) return null
        
        val data = canFrame.data
        if (data.size < 8) return null
        
        // è½¦é€Ÿè®¡ç®— (km/h)
        val speed = (((data[1].toInt() and 0xFF) shl 8) or 
                    (data[0].toInt() and 0xFF)) * 0.00390625
        
        return VehicleSpeedData(
            speed = speed,
            timestamp = System.currentTimeMillis()
        )
    }
}
```

### 3.3 å®æ—¶æ•°æ®ç›‘å¬æœåŠ¡

```kotlin
/**
 * CANæ•°æ®ç›‘å¬æœåŠ¡
 */
class CANDataService : Service() {
    
    private lateinit var canSocket: CANSocket
    private lateinit var dataParser: VehicleDataParser
    private val dataSubject = PublishSubject.create<VehicleData>()
    
    override fun onCreate() {
        super.onCreate()
        
        dataParser = VehicleDataParser()
        initCANSocket()
        startDataMonitoring()
    }
    
    private fun initCANSocket() {
        try {
            canSocket = CANSocket()
            canSocket.bind("can0")  // ç»‘å®šCANæ¥å£
        } catch (e: Exception) {
            Log.e("CANService", "Failed to init CAN socket", e)
        }
    }
    
    private fun startDataMonitoring() {
        Thread {
            while (!Thread.currentThread().isInterrupted) {
                try {
                    val frame = canSocket.recv()
                    processCANFrame(frame)
                } catch (e: Exception) {
                    Log.e("CANService", "Error reading CAN frame", e)
                }
            }
        }.start()
    }
    
    private fun processCANFrame(frame: CANFrame) {
        when (frame.id) {
            VehicleDataParser.ENGINE_DATA_ID -> {
                dataParser.parseEngineData(frame)?.let { engineData ->
                    dataSubject.onNext(VehicleData.Engine(engineData))
                }
            }
            VehicleDataParser.VEHICLE_SPEED_ID -> {
                dataParser.parseVehicleSpeed(frame)?.let { speedData ->
                    dataSubject.onNext(VehicleData.Speed(speedData))
                }
            }
        }
    }
    
    /**
     * æä¾›æ•°æ®è®¢é˜…æ¥å£
     */
    fun observeVehicleData(): Observable<VehicleData> = dataSubject
}
```

### 3.4 UIæ•°æ®ç»‘å®š

```kotlin
/**
 * æ™ºèƒ½ä»ªè¡¨ç•Œé¢
 */
class SmartDashboardActivity : AppCompatActivity() {
    
    private lateinit var binding: ActivityDashboardBinding
    private lateinit var canService: CANDataService
    private val disposables = CompositeDisposable()
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityDashboardBinding.inflate(layoutInflater)
        setContentView(binding.root)
        
        bindCANService()
        setupDataObservers()
    }
    
    private fun bindCANService() {
        val intent = Intent(this, CANDataService::class.java)
        bindService(intent, serviceConnection, Context.BIND_AUTO_CREATE)
    }
    
    private fun setupDataObservers() {
        canService.observeVehicleData()
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe { vehicleData ->
                updateUI(vehicleData)
            }
            .let { disposables.add(it) }
    }
    
    private fun updateUI(vehicleData: VehicleData) {
        when (vehicleData) {
            is VehicleData.Engine -> {
                binding.rpmGauge.setValue(vehicleData.data.rpm)
                binding.tempGauge.setValue(vehicleData.data.coolantTemperature)
                binding.oilPressureIndicator.setValue(vehicleData.data.oilPressure)
            }
            is VehicleData.Speed -> {
                binding.speedGauge.setValue(vehicleData.data.speed)
                updateAverageSpeed(vehicleData.data.speed)
            }
        }
    }
}
```

---

## 4. å®æˆ˜æ¡ˆä¾‹ï¼šè½¦è¾†æ§åˆ¶æŒ‡ä»¤å‘é€

### 4.1 åº”ç”¨åœºæ™¯

å®ç°ä¸€ä¸ªæ™ºèƒ½ç©ºè°ƒæ§åˆ¶åº”ç”¨ï¼Œæ”¯æŒï¼š
- æ¸©åº¦è°ƒèŠ‚
- é£é€Ÿæ§åˆ¶
- åº§æ¤…åŠ çƒ­
- è½¦çª—æ§åˆ¶

### 4.2 æ§åˆ¶æŒ‡ä»¤å®šä¹‰

```kotlin
/**
 * è½¦è¾†æ§åˆ¶æŒ‡ä»¤
 */
sealed class VehicleControlCommand {
    
    data class ClimateControl(
        val temperature: Int,        // æ¸©åº¦ï¼ˆâ„ƒï¼‰
        val fanSpeed: Int,          // é£é€Ÿç­‰çº§ 1-7
        val mode: ClimateMode       // ç©ºè°ƒæ¨¡å¼
    ) : VehicleControlCommand()
    
    data class SeatControl(
        val seat: SeatPosition,     // åº§æ¤…ä½ç½®
        val heatingLevel: Int       // åŠ çƒ­ç­‰çº§ 0-3
    ) : VehicleControlCommand()
    
    data class WindowControl(
        val window: WindowPosition, // è½¦çª—ä½ç½®
        val action: WindowAction    // æ“ä½œç±»å‹
    ) : VehicleControlCommand()
}

enum class ClimateMode(val value: Int) {
    AUTO(0x01), MANUAL(0x02), DEFROST(0x03)
}

enum class SeatPosition(val value: Int) {
    DRIVER(0x01), PASSENGER(0x02), REAR_LEFT(0x03), REAR_RIGHT(0x04)
}
```

### 4.3 CANæŒ‡ä»¤å‘é€å™¨

```kotlin
/**
 * CANæ§åˆ¶æŒ‡ä»¤å‘é€å™¨
 */
class CANCommandSender(private val canSocket: CANSocket) {
    
    companion object {
        const val CLIMATE_CONTROL_ID = 0x18FEF100
        const val SEAT_CONTROL_ID = 0x18FEF200
        const val WINDOW_CONTROL_ID = 0x18FEF300
    }
    
    /**
     * å‘é€ç©ºè°ƒæ§åˆ¶æŒ‡ä»¤
     */
    fun sendClimateControl(command: VehicleControlCommand.ClimateControl): Boolean {
        return try {
            val data = buildClimateControlFrame(command)
            val frame = CANFrame(CLIMATE_CONTROL_ID, data)
            canSocket.send(frame)
            
            Log.i("CANCommand", "Climate control sent: $command")
            true
        } catch (e: Exception) {
            Log.e("CANCommand", "Failed to send climate control", e)
            false
        }
    }
    
    private fun buildClimateControlFrame(command: VehicleControlCommand.ClimateControl): ByteArray {
        val data = ByteArray(8)
        
        // å­—èŠ‚0-1: æ¸©åº¦è®¾ç½® (0.5Â°Cåˆ†è¾¨ç‡)
        val tempValue = (command.temperature * 2).toShort()
        data[0] = (tempValue and 0xFF).toByte()
        data[1] = ((tempValue shr 8) and 0xFF).toByte()
        
        // å­—èŠ‚2: é£é€Ÿç­‰çº§
        data[2] = command.fanSpeed.toByte()
        
        // å­—èŠ‚3: ç©ºè°ƒæ¨¡å¼
        data[3] = command.mode.value.toByte()
        
        // å­—èŠ‚4-7: ä¿ç•™å­—æ®µ
        data[4] = 0xFF.toByte()
        data[5] = 0xFF.toByte()
        data[6] = 0xFF.toByte()
        data[7] = calculateChecksum(data, 7).toByte()
        
        return data
    }
    
    /**
     * å‘é€åº§æ¤…æ§åˆ¶æŒ‡ä»¤
     */
    fun sendSeatControl(command: VehicleControlCommand.SeatControl): Boolean {
        return try {
            val data = buildSeatControlFrame(command)
            val frame = CANFrame(SEAT_CONTROL_ID, data)
            canSocket.send(frame)
            
            Log.i("CANCommand", "Seat control sent: $command")
            true
        } catch (e: Exception) {
            Log.e("CANCommand", "Failed to send seat control", e)
            false
        }
    }
    
    private fun buildSeatControlFrame(command: VehicleControlCommand.SeatControl): ByteArray {
        val data = ByteArray(8)
        
        // å­—èŠ‚0: åº§æ¤…ä½ç½®
        data[0] = command.seat.value.toByte()
        
        // å­—èŠ‚1: åŠ çƒ­ç­‰çº§
        data[1] = command.heatingLevel.toByte()
        
        // å­—èŠ‚2-6: ä¿ç•™å­—æ®µ
        for (i in 2..6) {
            data[i] = 0xFF.toByte()
        }
        
        // å­—èŠ‚7: æ ¡éªŒå’Œ
        data[7] = calculateChecksum(data, 7).toByte()
        
        return data
    }
    
    /**
     * è®¡ç®—æ ¡éªŒå’Œ
     */
    private fun calculateChecksum(data: ByteArray, length: Int): Int {
        var checksum = 0
        for (i in 0 until length) {
            checksum += data[i].toInt() and 0xFF
        }
        return checksum and 0xFF
    }
}
```

### 4.4 æŒ‡ä»¤é˜Ÿåˆ—ä¸é‡è¯•æœºåˆ¶

```kotlin
/**
 * CANæŒ‡ä»¤ç®¡ç†å™¨ - æ”¯æŒé˜Ÿåˆ—å’Œé‡è¯•
 */
class CANCommandManager(private val commandSender: CANCommandSender) {
    
    private val commandQueue = LinkedBlockingQueue<CommandItem>()
    private val executorService = Executors.newSingleThreadExecutor()
    private val pendingCommands = mutableMapOf<String, CommandItem>()
    
    data class CommandItem(
        val id: String = UUID.randomUUID().toString(),
        val command: VehicleControlCommand,
        val retryCount: Int = 0,
        val maxRetries: Int = 3,
        val callback: ((Boolean) -> Unit)? = null
    )
    
    init {
        startCommandProcessor()
    }
    
    /**
     * æ·»åŠ æ§åˆ¶æŒ‡ä»¤åˆ°é˜Ÿåˆ—
     */
    fun executeCommand(
        command: VehicleControlCommand,
        callback: ((Boolean) -> Unit)? = null
    ) {
        val commandItem = CommandItem(
            command = command,
            callback = callback
        )
        commandQueue.offer(commandItem)
    }
    
    private fun startCommandProcessor() {
        executorService.submit {
            while (!Thread.currentThread().isInterrupted) {
                try {
                    val commandItem = commandQueue.take()
                    processCommand(commandItem)
                } catch (e: InterruptedException) {
                    Thread.currentThread().interrupt()
                    break
                } catch (e: Exception) {
                    Log.e("CANCommandManager", "Error processing command", e)
                }
            }
        }
    }
    
    private fun processCommand(commandItem: CommandItem) {
        val success = when (commandItem.command) {
            is VehicleControlCommand.ClimateControl -> {
                commandSender.sendClimateControl(commandItem.command)
            }
            is VehicleControlCommand.SeatControl -> {
                commandSender.sendSeatControl(commandItem.command)
            }
            is VehicleControlCommand.WindowControl -> {
                // å®ç°è½¦çª—æ§åˆ¶é€»è¾‘
                true
            }
        }
        
        if (success) {
            commandItem.callback?.invoke(true)
        } else {
            handleCommandFailure(commandItem)
        }
    }
    
    private fun handleCommandFailure(commandItem: CommandItem) {
        if (commandItem.retryCount < commandItem.maxRetries) {
            // é‡è¯•æœºåˆ¶
            val retryItem = commandItem.copy(retryCount = commandItem.retryCount + 1)
            
            // å»¶è¿Ÿé‡è¯•
            Thread.sleep(1000L * (commandItem.retryCount + 1))
            commandQueue.offer(retryItem)
            
            Log.w("CANCommandManager", 
                "Retrying command ${commandItem.id}, attempt ${retryItem.retryCount}")
        } else {
            // è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°ï¼Œé€šçŸ¥å¤±è´¥
            commandItem.callback?.invoke(false)
            Log.e("CANCommandManager", 
                "Command ${commandItem.id} failed after ${commandItem.maxRetries} retries")
        }
    }
}
```

---

## 5. æ•…éšœè¯Šæ–­ä¸OBDé›†æˆ

### 5.1 OBD-IIåè®®åŸºç¡€

```kotlin
/**
 * OBD-IIè¯Šæ–­æ•°æ®è¯»å–
 */
class OBDDiagnosticReader(private val canSocket: CANSocket) {
    
    companion object {
        const val OBD_REQUEST_ID = 0x7DF      // å¹¿æ’­è¯·æ±‚ID
        const val OBD_RESPONSE_ID_START = 0x7E8 // å“åº”IDèµ·å§‹èŒƒå›´
        const val OBD_RESPONSE_ID_END = 0x7EF   // å“åº”IDç»“æŸèŒƒå›´
        
        // å¸¸ç”¨PIDå®šä¹‰
        const val PID_ENGINE_RPM = 0x0C
        const val PID_VEHICLE_SPEED = 0x0D
        const val PID_THROTTLE_POSITION = 0x11
        const val PID_FUEL_PRESSURE = 0x0A
        const val PID_ENGINE_COOLANT_TEMP = 0x05
    }
    
    /**
     * è¯»å–æ•…éšœç 
     */
    fun readDiagnosticTroubleCodes(): List<DTCInfo> {
        val request = buildOBDRequest(0x03) // Mode 03: è¯»å–æ•…éšœç 
        
        return try {
            sendOBDRequest(request)
            val responses = readOBDResponses(5000) // 5ç§’è¶…æ—¶
            
            responses.mapNotNull { response ->
                parseDTCResponse(response)
            }.flatten()
        } catch (e: Exception) {
            Log.e("OBDReader", "Failed to read DTCs", e)
            emptyList()
        }
    }
    
    /**
     * è¯»å–å®æ—¶æ•°æ®
     */
    fun readPIDData(pid: Int): OBDData? {
        val request = buildPIDRequest(pid)
        
        return try {
            sendOBDRequest(request)
            val response = readOBDResponse(1000) // 1ç§’è¶…æ—¶
            
            response?.let { parsePIDResponse(it, pid) }
        } catch (e: Exception) {
            Log.e("OBDReader", "Failed to read PID $pid", e)
            null
        }
    }
    
    private fun buildOBDRequest(mode: Int, pid: Int? = null): ByteArray {
        return if (pid != null) {
            byteArrayOf(
                0x02,           // æ•°æ®é•¿åº¦
                mode.toByte(),  // æ¨¡å¼
                pid.toByte(),   // PID
                0x00, 0x00, 0x00, 0x00, 0x00
            )
        } else {
            byteArrayOf(
                0x01,           // æ•°æ®é•¿åº¦
                mode.toByte(),  // æ¨¡å¼
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00
            )
        }
    }
    
    private fun buildPIDRequest(pid: Int): ByteArray = buildOBDRequest(0x01, pid)
    
    private fun sendOBDRequest(request: ByteArray) {
        val frame = CANFrame(OBD_REQUEST_ID, request)
        canSocket.send(frame)
    }
    
    private fun readOBDResponse(timeoutMs: Long): CANFrame? {
        val startTime = System.currentTimeMillis()
        
        while (System.currentTimeMillis() - startTime < timeoutMs) {
            try {
                val frame = canSocket.recv(100) // 100msæ¥æ”¶è¶…æ—¶
                
                if (frame.id in OBD_RESPONSE_ID_START..OBD_RESPONSE_ID_END) {
                    return frame
                }
            } catch (e: Exception) {
                // ç»§ç»­ç­‰å¾…
            }
        }
        
        return null
    }
    
    private fun parsePIDResponse(frame: CANFrame, pid: Int): OBDData? {
        val data = frame.data
        if (data.size < 3) return null
        
        val responseMode = data[1].toInt() and 0xFF
        val responsePID = data[2].toInt() and 0xFF
        
        if (responseMode != 0x41 || responsePID != pid) return null
        
        return when (pid) {
            PID_ENGINE_RPM -> {
                if (data.size >= 5) {
                    val rpm = (((data[3].toInt() and 0xFF) shl 8) or 
                              (data[4].toInt() and 0xFF)) / 4.0
                    OBDData.EngineRPM(rpm)
                } else null
            }
            PID_VEHICLE_SPEED -> {
                if (data.size >= 4) {
                    val speed = data[3].toInt() and 0xFF
                    OBDData.VehicleSpeed(speed.toDouble())
                } else null
            }
            PID_ENGINE_COOLANT_TEMP -> {
                if (data.size >= 4) {
                    val temp = (data[3].toInt() and 0xFF) - 40
                    OBDData.CoolantTemperature(temp.toDouble())
                } else null
            }
            else -> null
        }
    }
}

/**
 * OBDæ•°æ®ç±»å‹
 */
sealed class OBDData {
    data class EngineRPM(val rpm: Double) : OBDData()
    data class VehicleSpeed(val speed: Double) : OBDData()
    data class CoolantTemperature(val temperature: Double) : OBDData()
    data class ThrottlePosition(val position: Double) : OBDData()
}

/**
 * æ•…éšœç ä¿¡æ¯
 */
data class DTCInfo(
    val code: String,           // æ•…éšœç  (ä¾‹å¦‚: P0301)
    val description: String,    // æ•…éšœæè¿°
    val severity: DTCSeverity   // ä¸¥é‡ç¨‹åº¦
)

enum class DTCSeverity {
    INFO, WARNING, ERROR, CRITICAL
}
```

---

## 6. å®‰å…¨ä¸æƒé™ç®¡ç†

### 6.1 CANå®‰å…¨å¨èƒåˆ†æ

è½¦è½½CANç½‘ç»œé¢ä¸´çš„ä¸»è¦å®‰å…¨å¨èƒï¼š

1. **æ¶ˆæ¯æ³¨å…¥æ”»å‡»**: æ¶æ„å‘é€è™šå‡CANæ¶ˆæ¯
2. **æ¶ˆæ¯é‡æ”¾æ”»å‡»**: é‡å¤å‘é€åˆæ³•æ¶ˆæ¯
3. **æ‹’ç»æœåŠ¡æ”»å‡»**: å‘é€å¤§é‡æ¶ˆæ¯å µå¡ç½‘ç»œ
4. **ä¸­é—´äººæ”»å‡»**: ç¯¡æ”¹ä¼ è¾“ä¸­çš„æ¶ˆæ¯

### 6.2 å®‰å…¨é˜²æŠ¤æœºåˆ¶

```kotlin
/**
 * CANæ¶ˆæ¯å®‰å…¨éªŒè¯å™¨
 */
class CANSecurityManager {
    
    private val messageCounter = mutableMapOf<Int, Long>()
    private val lastMessageTime = mutableMapOf<Int, Long>()
    private val trustedApplications = setOf("com.company.dashboard", "com.company.navigation")
    
    /**
     * éªŒè¯å‘é€æƒé™
     */
    fun validateSendPermission(
        appPackageName: String,
        canId: Int,
        data: ByteArray
    ): SecurityResult {
        
        // 1. éªŒè¯åº”ç”¨èº«ä»½
        if (!trustedApplications.contains(appPackageName)) {
            return SecurityResult.Denied("Untrusted application")
        }
        
        // 2. éªŒè¯CAN IDæƒé™
        if (!isAuthorizedForCANId(appPackageName, canId)) {
            return SecurityResult.Denied("Unauthorized CAN ID access")
        }
        
        // 3. éªŒè¯æ¶ˆæ¯é¢‘ç‡
        if (!validateMessageFrequency(canId)) {
            return SecurityResult.Denied("Message frequency limit exceeded")
        }
        
        // 4. éªŒè¯æ¶ˆæ¯å†…å®¹
        if (!validateMessageContent(canId, data)) {
            return SecurityResult.Denied("Invalid message content")
        }
        
        return SecurityResult.Allowed
    }
    
    /**
     * éªŒè¯æ¥æ”¶æƒé™
     */
    fun validateReceivePermission(
        appPackageName: String,
        canId: Int
    ): Boolean {
        return when {
            // å…¬å…±æ•°æ®ï¼ˆè½¦é€Ÿã€è½¬é€Ÿç­‰ï¼‰
            isPublicData(canId) -> true
            
            // éœ€è¦ç‰¹æ®Šæƒé™çš„æ•°æ®
            isPrivilegedData(canId) -> hasPrivilegedAccess(appPackageName)
            
            // è¯Šæ–­æ•°æ®
            isDiagnosticData(canId) -> hasDiagnosticAccess(appPackageName)
            
            else -> false
        }
    }
    
    private fun isAuthorizedForCANId(appPackageName: String, canId: Int): Boolean {
        val authorizedIds = getAuthorizedCANIds(appPackageName)
        return authorizedIds.contains(canId)
    }
    
    private fun validateMessageFrequency(canId: Int): Boolean {
        val currentTime = System.currentTimeMillis()
        val lastTime = lastMessageTime[canId] ?: 0
        val minInterval = getMinMessageInterval(canId)
        
        if (currentTime - lastTime < minInterval) {
            return false
        }
        
        lastMessageTime[canId] = currentTime
        return true
    }
    
    private fun validateMessageContent(canId: Int, data: ByteArray): Boolean {
        // æ ¹æ®CAN IDéªŒè¯æ•°æ®æ ¼å¼å’ŒèŒƒå›´
        return when (canId) {
            0x18FEF100 -> validateClimateControlData(data)
            0x18FEF200 -> validateSeatControlData(data)
            else -> true // é»˜è®¤å…è®¸
        }
    }
    
    private fun validateClimateControlData(data: ByteArray): Boolean {
        if (data.size != 8) return false
        
        // éªŒè¯æ¸©åº¦èŒƒå›´ (16-32Â°C)
        val temp = ((data[1].toInt() and 0xFF) shl 8) or (data[0].toInt() and 0xFF)
        val tempCelsius = temp / 2.0
        
        if (tempCelsius < 16 || tempCelsius > 32) return false
        
        // éªŒè¯é£é€Ÿç­‰çº§ (1-7)
        val fanSpeed = data[2].toInt() and 0xFF
        if (fanSpeed !in 1..7) return false
        
        return true
    }
}

sealed class SecurityResult {
    object Allowed : SecurityResult()
    data class Denied(val reason: String) : SecurityResult()
}
```

### 6.3 æ¶ˆæ¯åŠ å¯†ä¸è®¤è¯

```kotlin
/**
 * CANæ¶ˆæ¯åŠ å¯†ç®¡ç†å™¨
 */
class CANEncryptionManager {
    
    private val secretKey = generateSecretKey()
    private val mac = Mac.getInstance("HmacSHA256")
    
    init {
        mac.init(secretKey)
    }
    
    /**
     * åŠ å¯†CANæ¶ˆæ¯
     */
    fun encryptMessage(canId: Int, data: ByteArray): EncryptedCANFrame? {
        return try {
            // 1. ç”Ÿæˆæ¶ˆæ¯è®¤è¯ç 
            val messageWithId = ByteBuffer.allocate(4 + data.size)
                .putInt(canId)
                .put(data)
                .array()
            
            val authCode = mac.doFinal(messageWithId)
            
            // 2. åˆ›å»ºåŠ å¯†å¸§
            EncryptedCANFrame(
                originalId = canId,
                encryptedData = data, // å®é™…åœºæ™¯ä¸­éœ€è¦åŠ å¯†
                authCode = authCode.take(4).toByteArray(), // æˆªå–4å­—èŠ‚
                timestamp = System.currentTimeMillis()
            )
        } catch (e: Exception) {
            Log.e("CANEncryption", "Failed to encrypt message", e)
            null
        }
    }
    
    /**
     * éªŒè¯å¹¶è§£å¯†CANæ¶ˆæ¯
     */
    fun decryptMessage(encryptedFrame: EncryptedCANFrame): ByteArray? {
        return try {
            // 1. é‡æ–°è®¡ç®—è®¤è¯ç 
            val messageWithId = ByteBuffer.allocate(4 + encryptedFrame.encryptedData.size)
                .putInt(encryptedFrame.originalId)
                .put(encryptedFrame.encryptedData)
                .array()
            
            val expectedAuthCode = mac.doFinal(messageWithId).take(4).toByteArray()
            
            // 2. éªŒè¯è®¤è¯ç 
            if (!expectedAuthCode.contentEquals(encryptedFrame.authCode)) {
                Log.w("CANEncryption", "Authentication failed for message")
                return null
            }
            
            // 3. éªŒè¯æ—¶é—´æˆ³ï¼ˆé˜²é‡æ”¾æ”»å‡»ï¼‰
            val currentTime = System.currentTimeMillis()
            if (currentTime - encryptedFrame.timestamp > 5000) { // 5ç§’æœ‰æ•ˆæœŸ
                Log.w("CANEncryption", "Message timestamp expired")
                return null
            }
            
            // 4. è¿”å›è§£å¯†æ•°æ®
            encryptedFrame.encryptedData
        } catch (e: Exception) {
            Log.e("CANEncryption", "Failed to decrypt message", e)
            null
        }
    }
    
    private fun generateSecretKey(): SecretKeySpec {
        // å®é™…åœºæ™¯ä¸­åº”ä»å®‰å…¨å­˜å‚¨ä¸­è·å–å¯†é’¥
        val keyBytes = "MySecretCANKey12345678901234567890".toByteArray()
        return SecretKeySpec(keyBytes, "HmacSHA256")
    }
}

data class EncryptedCANFrame(
    val originalId: Int,
    val encryptedData: ByteArray,
    val authCode: ByteArray,
    val timestamp: Long
)
```

---

## 7. æ€§èƒ½ä¼˜åŒ–ä¸ç›‘æ§

### 7.1 CANç½‘ç»œæ€§èƒ½ç›‘æ§

```kotlin
/**
 * CANç½‘ç»œæ€§èƒ½ç›‘æ§å™¨
 */
class CANPerformanceMonitor {
    
    private val messageStats = mutableMapOf<Int, MessageStatistics>()
    private val networkMetrics = NetworkMetrics()
    private val alertThresholds = AlertThresholds()
    
    data class MessageStatistics(
        var totalCount: Long = 0,
        var errorCount: Long = 0,
        var avgLatency: Double = 0.0,
        var maxLatency: Long = 0,
        var lastUpdateTime: Long = 0
    )
    
    data class NetworkMetrics(
        var totalBandwidthUsage: Double = 0.0,
        var peakBandwidthUsage: Double = 0.0,
        var busLoadPercentage: Double = 0.0,
        var errorFrameCount: Long = 0
    )
    
    /**
     * è®°å½•CANæ¶ˆæ¯æ€§èƒ½æ•°æ®
     */
    fun recordMessage(canId: Int, latency: Long, isError: Boolean = false) {
        val stats = messageStats.getOrPut(canId) { MessageStatistics() }
        
        stats.totalCount++
        if (isError) stats.errorCount++
        
        // æ›´æ–°å»¶è¿Ÿç»Ÿè®¡
        stats.avgLatency = (stats.avgLatency * (stats.totalCount - 1) + latency) / stats.totalCount
        stats.maxLatency = maxOf(stats.maxLatency, latency)
        stats.lastUpdateTime = System.currentTimeMillis()
        
        // æ£€æŸ¥æ€§èƒ½å‘Šè­¦
        checkPerformanceAlerts(canId, stats)
    }
    
    /**
     * è®¡ç®—ç½‘ç»œè´Ÿè½½
     */
    fun calculateBusLoad(messagesPerSecond: Int, averageMessageSize: Int): Double {
        // CANæ€»çº¿ç†è®ºæœ€å¤§ååé‡ï¼ˆ500kbpsï¼‰
        val maxBitsPerSecond = 500_000.0
        
        // å®é™…ä½¿ç”¨çš„æ¯”ç‰¹æ•°ï¼ˆåŒ…å«åè®®å¼€é”€ï¼‰
        val usedBitsPerSecond = messagesPerSecond * (averageMessageSize * 8 + 64) // 64ä½åè®®å¼€é”€
        
        return (usedBitsPerSecond / maxBitsPerSecond) * 100.0
    }
    
    /**
     * ç”Ÿæˆæ€§èƒ½æŠ¥å‘Š
     */
    fun generatePerformanceReport(): CANPerformanceReport {
        val currentTime = System.currentTimeMillis()
        
        return CANPerformanceReport(
            timestamp = currentTime,
            messageStatistics = messageStats.toMap(),
            networkMetrics = networkMetrics.copy(),
            recommendations = generateRecommendations()
        )
    }
    
    private fun checkPerformanceAlerts(canId: Int, stats: MessageStatistics) {
        // æ£€æŸ¥é”™è¯¯ç‡
        val errorRate = stats.errorCount.toDouble() / stats.totalCount
        if (errorRate > alertThresholds.maxErrorRate) {
            triggerAlert(AlertType.HIGH_ERROR_RATE, canId, "Error rate: ${errorRate * 100}%")
        }
        
        // æ£€æŸ¥å»¶è¿Ÿ
        if (stats.avgLatency > alertThresholds.maxLatency) {
            triggerAlert(AlertType.HIGH_LATENCY, canId, "Avg latency: ${stats.avgLatency}ms")
        }
    }
    
    private fun generateRecommendations(): List<String> {
        val recommendations = mutableListOf<String>()
        
        // åˆ†ææ¶ˆæ¯é¢‘ç‡
        val highFrequencyMessages = messageStats.filter { (_, stats) ->
            val currentTime = System.currentTimeMillis()
            val messageRate = stats.totalCount * 1000.0 / (currentTime - stats.lastUpdateTime + 1)
            messageRate > 50 // è¶…è¿‡50æ¶ˆæ¯/ç§’
        }
        
        if (highFrequencyMessages.isNotEmpty()) {
            recommendations.add("è€ƒè™‘é™ä½é«˜é¢‘æ¶ˆæ¯çš„å‘é€é¢‘ç‡: ${highFrequencyMessages.keys}")
        }
        
        // åˆ†æç½‘ç»œè´Ÿè½½
        if (networkMetrics.busLoadPercentage > 70) {
            recommendations.add("ç½‘ç»œè´Ÿè½½è¿‡é«˜(${networkMetrics.busLoadPercentage}%)ï¼Œå»ºè®®ä¼˜åŒ–æ¶ˆæ¯è°ƒåº¦")
        }
        
        return recommendations
    }
    
    private fun triggerAlert(type: AlertType, canId: Int, details: String) {
        Log.w("CANPerformance", "Alert [$type] for CAN ID 0x${canId.toString(16)}: $details")
        
        // å¯ä»¥æ‰©å±•ä¸ºå‘é€é€šçŸ¥ç»™ç›‘æ§ç³»ç»Ÿ
        // notificationManager.sendAlert(type, canId, details)
    }
}

enum class AlertType {
    HIGH_ERROR_RATE, HIGH_LATENCY, NETWORK_CONGESTION
}

data class AlertThresholds(
    val maxErrorRate: Double = 0.05,    // 5%é”™è¯¯ç‡
    val maxLatency: Double = 100.0,     // 100msæœ€å¤§å»¶è¿Ÿ
    val maxBusLoad: Double = 80.0       // 80%æœ€å¤§æ€»çº¿è´Ÿè½½
)
```

### 7.2 æ¶ˆæ¯ä¼˜å…ˆçº§è°ƒåº¦

```kotlin
/**
 * CANæ¶ˆæ¯ä¼˜å…ˆçº§è°ƒåº¦å™¨
 */
class CANMessageScheduler {
    
    private val priorityQueues = mapOf(
        MessagePriority.CRITICAL to PriorityQueue<ScheduledMessage>(compareBy { it.deadline }),
        MessagePriority.HIGH to PriorityQueue<ScheduledMessage>(compareBy { it.deadline }),
        MessagePriority.NORMAL to PriorityQueue<ScheduledMessage>(compareBy { it.deadline }),
        MessagePriority.LOW to PriorityQueue<ScheduledMessage>(compareBy { it.deadline })
    )
    
    private val executor = Executors.newSingleThreadScheduledExecutor()
    private val canSocket: CANSocket by lazy { CANSocket().apply { bind("can0") } }
    
    data class ScheduledMessage(
        val canId: Int,
        val data: ByteArray,
        val priority: MessagePriority,
        val deadline: Long,
        val retryCount: Int = 0,
        val maxRetries: Int = 3
    )
    
    enum class MessagePriority(val level: Int) {
        CRITICAL(1),    // å®‰å…¨ç›¸å…³æ¶ˆæ¯
        HIGH(2),        // æ§åˆ¶æŒ‡ä»¤
        NORMAL(3),      // çŠ¶æ€æ›´æ–°
        LOW(4)          // è¯Šæ–­ä¿¡æ¯
    }
    
    init {
        startMessageScheduler()
    }
    
    /**
     * è°ƒåº¦CANæ¶ˆæ¯å‘é€
     */
    fun scheduleMessage(
        canId: Int,
        data: ByteArray,
        priority: MessagePriority = MessagePriority.NORMAL,
        deadlineMs: Long = System.currentTimeMillis() + 1000
    ) {
        val message = ScheduledMessage(canId, data, priority, deadlineMs)
        priorityQueues[priority]?.offer(message)
    }
    
    private fun startMessageScheduler() {
        executor.scheduleAtFixedRate({
            processMessageQueues()
        }, 0, 10, TimeUnit.MILLISECONDS) // 10msè°ƒåº¦å‘¨æœŸ
    }
    
    private fun processMessageQueues() {
        val currentTime = System.currentTimeMillis()
        
        // æŒ‰ä¼˜å…ˆçº§å¤„ç†æ¶ˆæ¯é˜Ÿåˆ—
        for (priority in MessagePriority.values()) {
            val queue = priorityQueues[priority] ?: continue
            
            while (queue.isNotEmpty()) {
                val message = queue.peek()
                
                // æ£€æŸ¥æ˜¯å¦è¿‡æœŸ
                if (message.deadline < currentTime) {
                    queue.poll()
                    handleExpiredMessage(message)
                    continue
                }
                
                // å°è¯•å‘é€æ¶ˆæ¯
                if (sendMessage(message)) {
                    queue.poll()
                } else {
                    // å‘é€å¤±è´¥ï¼Œå¤„ç†é‡è¯•é€»è¾‘
                    queue.poll()
                    handleSendFailure(message)
                }
                
                // æ¯ä¸ªå‘¨æœŸåªå¤„ç†ä¸€æ¡æ¶ˆæ¯ï¼Œç¡®ä¿å®æ—¶æ€§
                break
            }
        }
    }
    
    private fun sendMessage(message: ScheduledMessage): Boolean {
        return try {
            val frame = CANFrame(message.canId, message.data)
            canSocket.send(frame)
            
            Log.d("CANScheduler", 
                "Sent message CAN ID: 0x${message.canId.toString(16)}, Priority: ${message.priority}")
            true
        } catch (e: Exception) {
            Log.e("CANScheduler", "Failed to send message", e)
            false
        }
    }
    
    private fun handleSendFailure(message: ScheduledMessage) {
        if (message.retryCount < message.maxRetries) {
            // é‡æ–°è°ƒåº¦é‡è¯•
            val retryMessage = message.copy(
                retryCount = message.retryCount + 1,
                deadline = System.currentTimeMillis() + 100 // 100msåé‡è¯•
            )
            priorityQueues[message.priority]?.offer(retryMessage)
        } else {
            Log.e("CANScheduler", 
                "Message failed after ${message.maxRetries} retries: CAN ID 0x${message.canId.toString(16)}")
        }
    }
    
    private fun handleExpiredMessage(message: ScheduledMessage) {
        Log.w("CANScheduler", 
            "Message expired: CAN ID 0x${message.canId.toString(16)}, Priority: ${message.priority}")
    }
}
```

---

## 8. å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ

### 8.1 è¿æ¥ä¸åˆå§‹åŒ–é—®é¢˜

**é—®é¢˜1**: CANæ¥å£åˆå§‹åŒ–å¤±è´¥

```kotlin
// é”™è¯¯ç¤ºä¾‹
try {
    val canSocket = CANSocket()
    canSocket.bind("can0")  // å¯èƒ½å¤±è´¥
} catch (e: Exception) {
    // æ²¡æœ‰é€‚å½“çš„é”™è¯¯å¤„ç†
}

// æ­£ç¡®æ–¹æ¡ˆ
class CANConnectionManager {
    
    fun initializeCANSocket(interfaceName: String = "can0"): CANSocket? {
        return try {
            // 1. æ£€æŸ¥CANæ¥å£æ˜¯å¦å­˜åœ¨
            if (!isCANInterfaceAvailable(interfaceName)) {
                Log.e("CAN", "CAN interface $interfaceName not available")
                return null
            }
            
            // 2. åˆ›å»ºå¹¶é…ç½®socket
            val canSocket = CANSocket()
            canSocket.bind(interfaceName)
            
            // 3. éªŒè¯è¿æ¥
            if (testCANConnection(canSocket)) {
                Log.i("CAN", "CAN socket initialized successfully")
                canSocket
            } else {
                canSocket.close()
                null
            }
        } catch (e: Exception) {
            Log.e("CAN", "Failed to initialize CAN socket", e)
            null
        }
    }
    
    private fun isCANInterfaceAvailable(interfaceName: String): Boolean {
        return try {
            val process = Runtime.getRuntime().exec("ip link show $interfaceName")
            process.waitFor() == 0
        } catch (e: Exception) {
            false
        }
    }
    
    private fun testCANConnection(canSocket: CANSocket): Boolean {
        return try {
            // å‘é€æµ‹è¯•å¸§éªŒè¯è¿æ¥
            val testFrame = CANFrame(0x123, byteArrayOf(0x00))
            canSocket.send(testFrame)
            true
        } catch (e: Exception) {
            false
        }
    }
}
```

**é—®é¢˜2**: CANæ•°æ®è§£æé”™è¯¯

```kotlin
// é”™è¯¯ç¤ºä¾‹ - æ²¡æœ‰éªŒè¯æ•°æ®é•¿åº¦å’Œæ ¼å¼
fun parseSpeedData(frame: CANFrame): Int {
    return frame.data[0].toInt() // å¯èƒ½æ•°ç»„è¶Šç•Œ
}

// æ­£ç¡®æ–¹æ¡ˆ
fun parseSpeedData(frame: CANFrame): SpeedData? {
    return try {
        // 1. éªŒè¯CAN ID
        if (frame.id != EXPECTED_SPEED_CAN_ID) {
            Log.w("CAN", "Unexpected CAN ID for speed data: 0x${frame.id.toString(16)}")
            return null
        }
        
        // 2. éªŒè¯æ•°æ®é•¿åº¦
        if (frame.data.size < EXPECTED_DATA_LENGTH) {
            Log.w("CAN", "Insufficient data length: ${frame.data.size}")
            return null
        }
        
        // 3. è§£ææ•°æ®
        val rawSpeed = ((frame.data[1].toInt() and 0xFF) shl 8) or 
                       (frame.data[0].toInt() and 0xFF)
        val speed = rawSpeed * SPEED_SCALE_FACTOR
        
        // 4. éªŒè¯æ•°æ®åˆç†æ€§
        if (speed < 0 || speed > MAX_REASONABLE_SPEED) {
            Log.w("CAN", "Unreasonable speed value: $speed")
            return null
        }
        
        SpeedData(speed = speed, timestamp = System.currentTimeMillis())
    } catch (e: Exception) {
        Log.e("CAN", "Failed to parse speed data", e)
        null
    }
}
```

### 8.2 æ€§èƒ½ä¸ç¨³å®šæ€§é—®é¢˜

**é—®é¢˜3**: CANæ¶ˆæ¯ä¸¢å¤±

```kotlin
// é—®é¢˜åˆ†æä¸è§£å†³æ–¹æ¡ˆ
class CANMessageLossDetector {
    
    private val expectedSequenceNumbers = mutableMapOf<Int, Int>()
    private val missedMessages = mutableMapOf<Int, MutableList<Int>>()
    
    fun detectMessageLoss(canId: Int, sequenceNumber: Int) {
        val expected = expectedSequenceNumbers[canId] ?: 0
        
        if (sequenceNumber != expected) {
            // æ£€æµ‹åˆ°æ¶ˆæ¯ä¸¢å¤±
            val missed = mutableListOf<Int>()
            for (i in expected until sequenceNumber) {
                missed.add(i)
            }
            
            missedMessages.getOrPut(canId) { mutableListOf() }.addAll(missed)
            
            Log.w("CAN", "Message loss detected for CAN ID 0x${canId.toString(16)}: $missed")
            
            // è¯·æ±‚é‡ä¼ ä¸¢å¤±çš„æ¶ˆæ¯
            requestRetransmission(canId, missed)
        }
        
        expectedSequenceNumbers[canId] = sequenceNumber + 1
    }
    
    private fun requestRetransmission(canId: Int, missedSequences: List<Int>) {
        // å®ç°é‡ä¼ è¯·æ±‚é€»è¾‘
        val retransmissionRequest = buildRetransmissionRequest(canId, missedSequences)
        // å‘é€é‡ä¼ è¯·æ±‚...
    }
}
```

**é—®é¢˜4**: å†…å­˜æ³„æ¼

```kotlin
// é”™è¯¯ç¤ºä¾‹ - æ²¡æœ‰æ­£ç¡®ç®¡ç†èµ„æº
class CANService {
    private val canSocket = CANSocket()
    private val listeners = mutableListOf<CANMessageListener>()
    
    fun addListener(listener: CANMessageListener) {
        listeners.add(listener) // å¯èƒ½å¯¼è‡´å†…å­˜æ³„æ¼
    }
}

// æ­£ç¡®æ–¹æ¡ˆ - ä½¿ç”¨WeakReferenceå’Œç”Ÿå‘½å‘¨æœŸç®¡ç†
class CANService {
    
    private val canSocket = CANSocket()
    private val listeners = mutableListOf<WeakReference<CANMessageListener>>()
    private val receiveThread: Thread? = null
    private var isRunning = false
    
    fun addListener(listener: CANMessageListener) {
        listeners.add(WeakReference(listener))
        cleanupListeners() // å®šæœŸæ¸…ç†æ— æ•ˆå¼•ç”¨
    }
    
    fun removeListener(listener: CANMessageListener) {
        listeners.removeAll { it.get() == listener || it.get() == null }
    }
    
    private fun cleanupListeners() {
        listeners.removeAll { it.get() == null }
    }
    
    fun start() {
        if (isRunning) return
        
        isRunning = true
        receiveThread = Thread {
            while (isRunning && !Thread.currentThread().isInterrupted) {
                try {
                    val frame = canSocket.recv()
                    notifyListeners(frame)
                } catch (e: InterruptedException) {
                    Thread.currentThread().interrupt()
                    break
                } catch (e: Exception) {
                    Log.e("CAN", "Error receiving frame", e)
                }
            }
        }.apply { start() }
    }
    
    fun stop() {
        isRunning = false
        receiveThread?.interrupt()
        receiveThread?.join(1000) // ç­‰å¾…æœ€å¤š1ç§’
        
        try {
            canSocket.close()
        } catch (e: Exception) {
            Log.e("CAN", "Error closing socket", e)
        }
    }
    
    private fun notifyListeners(frame: CANFrame) {
        listeners.forEach { ref ->
            ref.get()?.onCANMessage(frame)
        }
        cleanupListeners()
    }
}
```

### 8.3 è°ƒè¯•æŠ€å·§

**æŠ€å·§1**: CANæ¶ˆæ¯ç›‘æ§å·¥å…·

```bash
# ä½¿ç”¨candumpç›‘æ§CANæ¶ˆæ¯
candump can0

# è¿‡æ»¤ç‰¹å®šCAN ID
candump can0,123:7FF

# ä¿å­˜ç›‘æ§æ•°æ®åˆ°æ–‡ä»¶
candump -L can0 > can_log.txt

# åˆ†æCANæ—¥å¿—
canplayer -I can_log.txt
```

**æŠ€å·§2**: CANç½‘ç»œæµ‹è¯•

```kotlin
/**
 * CANç½‘ç»œæµ‹è¯•å·¥å…·
 */
class CANNetworkTester {
    
    fun performLoopbackTest(canSocket: CANSocket): Boolean {
        return try {
            val testData = byteArrayOf(0x12, 0x34, 0x56, 0x78)
            val testFrame = CANFrame(0x123, testData)
            
            // å‘é€æµ‹è¯•å¸§
            canSocket.send(testFrame)
            
            // æ¥æ”¶å¹¶éªŒè¯
            val receivedFrame = canSocket.recv(1000) // 1ç§’è¶…æ—¶
            
            receivedFrame.id == 0x123 && 
            receivedFrame.data.contentEquals(testData)
        } catch (e: Exception) {
            Log.e("CANTest", "Loopback test failed", e)
            false
        }
    }
    
    fun measureLatency(canSocket: CANSocket, iterations: Int = 100): Double {
        val latencies = mutableListOf<Long>()
        
        repeat(iterations) {
            val startTime = System.nanoTime()
            
            val testFrame = CANFrame(0x123, byteArrayOf(it.toByte()))
            canSocket.send(testFrame)
            
            try {
                canSocket.recv(100) // 100msè¶…æ—¶
                val endTime = System.nanoTime()
                latencies.add(endTime - startTime)
            } catch (e: Exception) {
                // å¿½ç•¥è¶…æ—¶
            }
        }
        
        return if (latencies.isNotEmpty()) {
            latencies.average() / 1_000_000.0 // è½¬æ¢ä¸ºæ¯«ç§’
        } else {
            -1.0
        }
    }
}
```

---

## ğŸ“Š æ€»ç»“

CANæ€»çº¿é›†æˆæ˜¯è½¦è½½åº”ç”¨å¼€å‘çš„æ ¸å¿ƒæŠ€æœ¯ï¼Œæœ¬æ–‡é€šè¿‡å®æˆ˜æ¡ˆä¾‹è¯¦ç»†ä»‹ç»äº†ï¼š

### âœ… æ ¸å¿ƒæŠ€æœ¯è¦ç‚¹

1. **CANæ¶ˆæ¯è§£æ**: æ­£ç¡®ç†è§£åè®®æ ¼å¼å’Œæ•°æ®ç»“æ„
2. **å®æ—¶æ•°æ®å¤„ç†**: é«˜æ•ˆçš„æ¶ˆæ¯ç›‘å¬å’Œå¤„ç†æœºåˆ¶
3. **æ§åˆ¶æŒ‡ä»¤å‘é€**: å®‰å…¨å¯é çš„è½¦è¾†æ§åˆ¶å®ç°
4. **æ•…éšœè¯Šæ–­**: OBD-IIåè®®é›†æˆå’Œæ•…éšœç è§£æ
5. **å®‰å…¨é˜²æŠ¤**: æƒé™ç®¡ç†ã€æ¶ˆæ¯éªŒè¯ã€åŠ å¯†ä¼ è¾“
6. **æ€§èƒ½ä¼˜åŒ–**: æ¶ˆæ¯è°ƒåº¦ã€ç½‘ç»œç›‘æ§ã€èµ„æºç®¡ç†

### ğŸ¯ æœ€ä½³å®è·µå»ºè®®

- **å®‰å…¨ç¬¬ä¸€**: ä¸¥æ ¼çš„æƒé™æ§åˆ¶å’Œæ¶ˆæ¯éªŒè¯
- **æ€§èƒ½ä¼˜åŒ–**: åˆç†çš„æ¶ˆæ¯è°ƒåº¦å’Œèµ„æºç®¡ç†
- **é”™è¯¯å¤„ç†**: å®Œå–„çš„å¼‚å¸¸å¤„ç†å’Œæ¢å¤æœºåˆ¶
- **è°ƒè¯•æ”¯æŒ**: å……åˆ†çš„æ—¥å¿—è®°å½•å’Œç›‘æ§å·¥å…·
- **æ ‡å‡†éµå¾ª**: ä¸¥æ ¼æŒ‰ç…§æ±½è½¦è¡Œä¸šæ ‡å‡†å®ç°

### ğŸš€ è¿›é˜¶æ–¹å‘

- **é«˜çº§è¯Šæ–­**: UDSåè®®æ·±åº¦é›†æˆ
- **ç½‘ç»œå®‰å…¨**: CANå®‰å…¨ç½‘å…³å’Œå…¥ä¾µæ£€æµ‹
- **AIé›†æˆ**: æ™ºèƒ½æ•…éšœé¢„æµ‹å’Œè¯Šæ–­
- **äº‘ç«¯è¿æ¥**: CANæ•°æ®äº‘ç«¯åˆ†æå’Œè¿œç¨‹è¯Šæ–­

é€šè¿‡æŒæ¡è¿™äº›CANæ€»çº¿é›†æˆæŠ€æœ¯ï¼Œæ‚¨å°†èƒ½å¤Ÿå¼€å‘å‡ºä¸“ä¸šã€å®‰å…¨ã€é«˜æ€§èƒ½çš„è½¦è½½åº”ç”¨ç³»ç»Ÿã€‚

---

**å…³äºæ™ºäº‘ç§‘æŠ€**

æ™ºäº‘ç§‘æŠ€ä¸“æ³¨äºè½¦è½½åº”ç”¨å¼€å‘å’ŒCANæ€»çº¿é›†æˆè§£å†³æ–¹æ¡ˆï¼Œæ‹¥æœ‰ä¸°å¯Œçš„æ±½è½¦ç”µå­å¼€å‘ç»éªŒã€‚å¦‚éœ€æŠ€æœ¯å’¨è¯¢æˆ–é¡¹ç›®åˆä½œï¼Œæ¬¢è¿è”ç³»æˆ‘ä»¬ã€‚

ğŸ“§ **è”ç³»é‚®ç®±**: can-support@zhiyun-tech.com  
ğŸ“ **æŠ€æœ¯çƒ­çº¿**: 400-123-4567  
ğŸŒ **å®˜æ–¹ç½‘ç«™**: https://www.zhiyun-tech.com